"""
Base strategy interface.

Strategies generate intents from spot-derived features.
Intents are then converted to specific option contracts by the contract selector.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from typing import List, Optional, Dict, Any, Literal

from ..data.models import MarketSnapshot


@dataclass
class Intent:
    """
    Trading intent generated by a strategy.
    
    Represents what position to take based on spot-derived analysis.
    The execution layer converts this into specific option contracts.
    """
    timestamp: datetime  # When the intent is generated
    direction: Literal["LONG", "SHORT", "FLAT"]  # Position direction
    option_type: Optional[Literal["CALL", "PUT"]] = None  # Call or Put (if direction != FLAT)
    size: int = 1  # Number of contracts (will be adjusted by risk manager)
    metadata: Dict[str, Any] = None  # Strategy-specific metadata
    
    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}


class Strategy(ABC):
    """
    Abstract base class for trading strategies.
    
    Strategies analyze spot/index data and generate intents (what position to take).
    The execution layer handles contract selection and order fills.
    """
    
    def __init__(self, params: Dict[str, Any]):
        """
        Initialize strategy with parameters.
        
        Args:
            params: Strategy-specific parameters from config
        """
        self.params = params
    
    @abstractmethod
    def generate_intents(
        self,
        snapshot: MarketSnapshot,
        context: Optional[Dict[str, Any]] = None,
    ) -> List[Intent]:
        """
        Generate trading intents from market snapshot.
        
        Args:
            snapshot: Current market snapshot (spot bar + optional futures + option chain)
            context: Optional context (previous positions, PnL, etc.)
            
        Returns:
            List of Intent objects (usually 0 or 1, but can support multi-leg strategies)
        """
        pass
    
    def on_trade_filled(self, intent: Intent, contract: str, fill_price: float, quantity: int):
        """
        Callback when a trade is filled (optional).
        
        Args:
            intent: Original intent
            contract: Selected contract symbol
            fill_price: Fill price
            quantity: Filled quantity
        """
        pass
    
    def on_trade_closed(self, intent: Intent, contract: str, pnl: float):
        """
        Callback when a trade is closed (optional).
        
        Args:
            intent: Original intent
            contract: Contract symbol
            pnl: Realized PnL
        """
        pass

